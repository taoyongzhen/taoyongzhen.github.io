<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android, 程序猿" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="陶永臻">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="陶永臻">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="陶永臻">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>陶永臻</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陶永臻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不恋过去，不畏将来</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/handler-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/handler-2/" itemprop="url">Android消息机制Handler篇2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T18:31:12+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本篇是handler消息机制第二篇，专注于handler机制的native方法的介绍。鉴于笔者不懂c++知识，该篇仅为参考资料[1]和[2]的读书笔记，望读者见谅。</p>
<h2 id="二、预备知识"><a href="#二、预备知识" class="headerlink" title="二、预备知识"></a>二、预备知识</h2><p>epoll是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作。handler获取不断消息，当前无消息可处理时，利用epoll机制进行阻塞，让出cpu，这样就不会导致ui线程卡顿，进而引发anr问题。详见参考[3].</p>
<h2 id="三、函数描述"><a href="#三、函数描述" class="headerlink" title="三、函数描述"></a>三、函数描述</h2><p>该部分简要描述native函数在整个消息机制中的作用。</p>
<h3 id="3-1-函数nativeInit"><a href="#3-1-函数nativeInit" class="headerlink" title="3.1 函数nativeInit()"></a>3.1 函数<code>nativeInit()</code></h3><p>函数<code>nativeInit()</code>作用创建native消息机制。<br><img src="/2018/05/06/handler-2/handler_native_init.png" alt="Handler-nativeInit"></p>
<h3 id="3-2-函数nativeDestroy-long-ptr"><a href="#3-2-函数nativeDestroy-long-ptr" class="headerlink" title="3.2 函数nativeDestroy(long ptr)"></a>3.2 函数<code>nativeDestroy(long ptr)</code></h3><p>函数<code>nativeDestroy(long ptr)</code>作用销毁native消息机制。<br><img src="/2018/05/06/handler-2/handler_native_destroy.png" alt="Handler-destroy"></p>
<h3 id="3-3-函数nativePollOnce-long-ptr-int-timeoutMillis"><a href="#3-3-函数nativePollOnce-long-ptr-int-timeoutMillis" class="headerlink" title="3.3 函数nativePollOnce(long ptr,int timeoutMillis)"></a>3.3 函数<code>nativePollOnce(long ptr,int timeoutMillis)</code></h3><p>函数<code>nativePollOnce(long ptr, int timeoutMillis)</code>作用native消息处理机制。<br><img src="/2018/05/06/handler-2/handler_native_deal.png" alt="Handler-deal"></p>
<h3 id="3-4-函数nativeWake-long-ptr"><a href="#3-4-函数nativeWake-long-ptr" class="headerlink" title="3.4 函数nativeWake(long ptr)"></a>3.4 函数<code>nativeWake(long ptr)</code></h3><p>函数<code>nativeWake(long ptr)</code>作用唤醒native消息机制。<br><img src="/2018/05/06/handler-2/handler_native_wake.png" alt="Handler-wake"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Android的handler消息机制由java层和native层两层消息机制构成，如图所示（图来自参考资料[1]）.<br><img src="/2018/05/06/handler-2/handler_native_all.png" alt="Handler-all"></p>
<ul>
<li>Java层可以发送Message，native层也可以发送.当然，不同层次的Message是放在不同层次的消息队列中，予以不同的方式处理；</li>
<li>在Java层，每次尝试从队列中获取一个Message，而后dispatch它。而C++层的消息则尽量在一次pollOnce中集中处理完毕，这是它们的一点不同。</li>
<li>消息处理流程是先处理Native Message，再处理Native Request，最后处理Java Message。理解了该流程，也就明白有时上层消息很少，但响应时间却较长的真正原因。</li>
</ul>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ol>
<li><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="external">handler-java详解</a></li>
<li><a href="https://my.oschina.net/youranhongcha/blog/492591" target="_blank" rel="external">handler详解</a> </li>
<li><a href="http://gityuan.com/2015/12/06/linux_epoll/" target="_blank" rel="external">epoll知识</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/handler-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/handler-1/" itemprop="url">Android消息机制Handler篇1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T16:25:55+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Handler/" itemprop="url" rel="index">
                    <span itemprop="name">Handler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在Android平台上，主要的通信机制有两种：Binder机制和消息机制（handler），前者用于跨进程通信，后者用于进程内部通信。Android系统的交互基本上是由二者合作完成的。首先由Binder完成跨进程消息交互，然后交由handler完成进程内部消息交互。例如Android四大组件Activity，Service，Broadcast, ContentProvider的启动交互过程都是依靠二者完成的。<br><img src="/2018/05/01/handler-1/handler-main.jpg" alt="Handler简图"></p>
<h2 id="二、模型"><a href="#二、模型" class="headerlink" title="二、模型"></a>二、模型</h2><p>Handler消息机制和现实生活中的信件传递基本类似，都包含<strong>发-转-收</strong>过程，Handler消息机制主要有以下小伙伴各司其职共同完成发、转和收的：</p>
<ul>
<li>Handler：消息的发送者（Handler.sendMessage）—类似于信件发送者和消息的响应者（Handler.handleMessage）—类似于信件处理者；  </li>
<li>Message：消息的封装，可分为异步消息和同步消息 — 类似于信件；  </li>
<li>MessageQueue：消息队列的主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next) —类似于邮局，完成收取信件和分发信件；  </li>
<li>Looper：不断循环执行(Looper.loop)，按分发机制将消息分发给目标处理者 —类似于邮递员，完成信件投递。<br>下面针对消息机制的各个小伙伴展开详细描述。</li>
</ul>
<h2 id="三、Message"><a href="#三、Message" class="headerlink" title="三、Message"></a>三、Message</h2><p>Message是消息的封装。主要包含以下成员变量：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">成员变量</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">详细描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">what</td>
<td style="text-align:center">int</td>
<td style="text-align:center">消息类型，消息区分，命名空间为Handler</td>
</tr>
<tr>
<td style="text-align:center">arg1</td>
<td style="text-align:center">int</td>
<td style="text-align:center">简单整型数据传递</td>
</tr>
<tr>
<td style="text-align:center">arg2</td>
<td style="text-align:center">int</td>
<td style="text-align:center">简单整型数据传递</td>
</tr>
<tr>
<td style="text-align:center">obj</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">任意对象传递，跨进程需要序列化</td>
</tr>
<tr>
<td style="text-align:center">replyTo</td>
<td style="text-align:center">Messenger</td>
<td style="text-align:center">消息的响应者，进行消息双向交互</td>
</tr>
<tr>
<td style="text-align:center">when</td>
<td style="text-align:center">long</td>
<td style="text-align:center">消息响应时间</td>
</tr>
<tr>
<td style="text-align:center">data</td>
<td style="text-align:center">Bundle</td>
<td style="text-align:center">跨进程传递消息，优先级高于obj</td>
</tr>
<tr>
<td style="text-align:center">target</td>
<td style="text-align:center">Handler</td>
<td style="text-align:center">消息的响应者</td>
</tr>
<tr>
<td style="text-align:center">callback</td>
<td style="text-align:center">Runnable</td>
<td style="text-align:center">消息自身携带的回调处理</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">Message</td>
<td style="text-align:center">下一条待处理消息</td>
</tr>
</tbody>
</table>
<p>创建消息，只需要对上述属性进行赋值。注意存在一类特殊的消息，其target为null，称之为同步分隔栏，起作用优先执行队列异步消息，详见参考[3]  </p>
<h3 id="3-1-消息的获取"><a href="#3-1-消息的获取" class="headerlink" title="3.1 消息的获取"></a>3.1 消息的获取</h3><p>消息获取方式有二：1. 通过构造方法<code>Message()</code>获取; 2. 通过<code>obtain()</code>函数获取。这里推荐第二中方式，原因：这里维护一个消息池，达到消息复用的目的。</p>
<h3 id="3-1-1-消息的复用"><a href="#3-1-1-消息的复用" class="headerlink" title="3.1.1 消息的复用"></a>3.1.1 消息的复用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Return a new Message instance from the global pool. Allows us to</div><div class="line">    * avoid allocating new objects in many cases.</div><div class="line">    * 在消息池存在消息时，返回已有消息；反之，创建新消息</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">           <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;<span class="comment">//消息队列存在消息消息判断</span></div><div class="line">               Message m = sPool;<span class="comment">//将队首消息指向返回消息</span></div><div class="line">               sPool = m.next;<span class="comment">//队首消息重新赋值</span></div><div class="line">               m.next = <span class="keyword">null</span>;</div><div class="line">               m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag 清空已使用标志</span></div><div class="line">               sPoolSize--;<span class="comment">//可用消息数目减一</span></div><div class="line">               <span class="keyword">return</span> m;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Message();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="3-1-2-消息的回收"><a href="#3-1-2-消息的回收" class="headerlink" title="3.1.2 消息的回收"></a>3.1.2 消息的回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     *检查消息是否可以回收</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isInUse()) &#123;</div><div class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></div><div class="line">                        + <span class="string">"is still in use."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        recycleUnchecked();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Recycles a Message that may be in-use.</div><div class="line">     * Used internally by the MessageQueue and Looper when disposing of queued Messages.</div><div class="line">     * 消息回收</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></div><div class="line">        <span class="comment">// Clear out all other details.</span></div><div class="line">        <span class="comment">//清理使用痕迹</span></div><div class="line">        flags = FLAG_IN_USE;</div><div class="line">        what = <span class="number">0</span>;</div><div class="line">        arg1 = <span class="number">0</span>;</div><div class="line">        arg2 = <span class="number">0</span>;</div><div class="line">        obj = <span class="keyword">null</span>;</div><div class="line">        replyTo = <span class="keyword">null</span>;</div><div class="line">        sendingUid = -<span class="number">1</span>;</div><div class="line">        when = <span class="number">0</span>;</div><div class="line">        target = <span class="keyword">null</span>;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">        data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<span class="comment">//添加到消息复用队列</span></div><div class="line">                next = sPool;</div><div class="line">                sPool = <span class="keyword">this</span>;</div><div class="line">                sPoolSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h2><p>MessageQueue顾名思义，即为消息队列，维护同一个线程下所有待处理的消息。该部分包含native方法，是联系java层和c++层的桥梁，其中native方法将在下一篇讲述。</p>
<h3 id="4-1-消息的添加"><a href="#4-1-消息的添加" class="headerlink" title="4.1 消息的添加"></a>4.1 消息的添加</h3><p>消息的添加是通过函数<code>enqueueMessage</code>和<code>postSyncBarrier</code>完成的。其中函数<code>enqueueMessage</code>完成一般消息的插入；函数<code>postSyncBarrier</code>完成“同步分隔栏”消息的出入。</p>
<h4 id="4-1-1-函数enqueueMessage"><a href="#4-1-1-函数enqueueMessage" class="headerlink" title="4.1.1 函数enqueueMessage"></a>4.1.1 函数<code>enqueueMessage</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 消息的添加</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> msg</div><div class="line">     * <span class="doctag">@param</span> when</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//消息的处理者为空，抛出异常（同步分隔栏消息，target为null，提供特殊的插入队列方法）</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//正在使用的消息，不能再次入队</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//消息机制退出时，不能插入新消息</span></div><div class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.markInUse();<span class="comment">//标识消息正在使用</span></div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;<span class="comment">//mMessages标示队首消息</span></div><div class="line">            <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;<span class="comment">//队列为空；消息响应绝对时间为0（立马响应）；消息响应绝对时间小于队首消息响应时间</span></div><div class="line">                <span class="comment">// New head, wake up the event queue if blocked.插入队首。若消息队列阻塞，将其唤醒</span></div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;<span class="comment">//重新设置队首消息</span></div><div class="line">                needWake = mBlocked;<span class="comment">//唤醒队列</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">                <span class="comment">//队列不为空，依其处理时间，插入对应位置。</span></div><div class="line">                <span class="comment">//唤醒条件：1.阻塞+2.队首为同步分隔栏+3.插入消息为异步消息</span></div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//再次判断是否需要唤醒队列：新插入信息之前存在异步消息，则无需唤醒。</span></div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//插入消息</span></div><div class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">            <span class="keyword">if</span> (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="4-1-2-函数postSyncBarrier"><a href="#4-1-2-函数postSyncBarrier" class="headerlink" title="4.1.2 函数postSyncBarrier"></a>4.1.2 函数<code>postSyncBarrier</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Posts a synchronization barrier to the Looper's message queue.</div><div class="line">     * 插入同步分隔栏消息</div><div class="line">     *</div><div class="line">     * Message processing occurs as usual until the message queue encounters the</div><div class="line">     * synchronization barrier that has been posted.  When the barrier is encountered,</div><div class="line">     * later synchronous messages in the queue are stalled (prevented from being executed)</div><div class="line">     * until the barrier is released by calling &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; and specifying</div><div class="line">     * the token that identifies the synchronization barrier.</div><div class="line">     * 同步分隔栏消息作用：导致同步消息阻塞处理，直到同步分隔栏消息释放；</div><div class="line">     *</div><div class="line">     * This method is used to immediately postpone execution of all subsequently posted</div><div class="line">     * synchronous messages until a condition is met that releases the barrier.</div><div class="line">     * Asynchronous messages (see &#123;<span class="doctag">@link</span> Message#isAsynchronous&#125; are exempt from the barrier</div><div class="line">     * and continue to be processed as usual.</div><div class="line">     * 同步分隔栏消息作用：只对同步消息阻塞，异步消息正常处理；</div><div class="line">     *</div><div class="line">     * This call must be always matched by a call to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; with</div><div class="line">     * the same token to ensure that the message queue resumes normal operation.</div><div class="line">     * Otherwise the application will probably hang!</div><div class="line">     * postSyncBarrier和removeSyncBarrier应该成对调用</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> when = SystemClock.uptimeMillis())</div><div class="line">     * <span class="doctag">@return</span> A token that uniquely identifies the barrier.  This token must be</div><div class="line">     * passed to &#123;<span class="doctag">@link</span> #removeSyncBarrier&#125; to release the barrier.</div><div class="line">     * <span class="doctag">@hide</span></div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></div><div class="line">        <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></div><div class="line">        <span class="comment">//不再唤醒队列的原因：它的作用阻塞同步消息的执行，为后插入的异步消息让路。它的使用姿势：插入同步分隔栏--插入异步消息--释放同步分隔栏</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;<span class="comment">//初始化token</span></div><div class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            msg.arg1 = token;</div><div class="line"></div><div class="line">            Message prev = <span class="keyword">null</span>;</div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//插入到合适位置</span></div><div class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                msg.next = p;</div><div class="line">                prev.next = msg;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> token;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-消息的移除"><a href="#4-2-消息的移除" class="headerlink" title="4.2 消息的移除"></a>4.2 消息的移除</h3><p>同样，针对普通消息和同步分隔栏这不同的消息，提供了不同的消息移除方法。普通消息移除方法有：函数<code>hasMessages(Handler h, int what, Object object)</code>，函数<code>removeMessages(Handler h, Runnable r, Object object)</code>和函数<code>removeCallbacksAndMessages(Handler h, Object object)</code>。它们实现原理基本类似，遍历队列，找出对应消息，标记为可复用。移除同步分隔栏消息：函数<code>removeSyncBarrier(int token)</code>。</p>
<h4 id="4-2-1-普通消息的移除"><a href="#4-2-1-普通消息的移除" class="headerlink" title="4.2.1 普通消息的移除"></a>4.2.1 普通消息的移除</h4><p>这里以函数<code>removeCallbacksAndMessages</code>为例简单分析一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 移除消息</div><div class="line">     * <span class="doctag">@param</span> h 消息发送者</div><div class="line">     * <span class="doctag">@param</span> object 消息携带数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Handler h, Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Message p = mMessages;</div><div class="line"></div><div class="line">            <span class="comment">// Remove all messages at front. 从队首移除消息</span></div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h</div><div class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</div><div class="line">                Message n = p.next;</div><div class="line">                mMessages = n;</div><div class="line">                p.recycleUnchecked();<span class="comment">//标记回收</span></div><div class="line">                p = n;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Remove all messages after front. 继续移除消息</span></div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                Message n = p.next;</div><div class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (n.target == h &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</div><div class="line">                        Message nn = n.next;</div><div class="line">                        n.recycleUnchecked();</div><div class="line">                        p.next = nn;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                p = n;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="4-2-2-同步分隔栏消息移除"><a href="#4-2-2-同步分隔栏消息移除" class="headerlink" title="4.2.2 同步分隔栏消息移除"></a>4.2.2 同步分隔栏消息移除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Removes a synchronization barrier.</div><div class="line">     * 移除同步分隔栏</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> token The synchronization barrier token that was returned by</div><div class="line">     *              &#123;<span class="doctag">@link</span> #postSyncBarrier&#125;.</div><div class="line">     *              插入时，返回的token</div><div class="line">     * <span class="doctag">@throws</span> IllegalStateException if the barrier was not found.</div><div class="line">     * <span class="doctag">@hide</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</div><div class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></div><div class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            Message prev = <span class="keyword">null</span>;</div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="comment">//同步分隔栏target为null。所以依据1.p.targe和token进行删选</span></div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//未能发现同步分隔栏，抛出异常</span></div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></div><div class="line">                        + <span class="string">" barrier token has not been posted or has already been removed."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="comment">//t</span></div><div class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;<span class="comment">//删除非头部消息，无需重新唤醒，因为唤醒时间是以队首节点处理时间设置的</span></div><div class="line">                prev.next = p.next;</div><div class="line">                needWake = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//同步分隔栏位于队首，其后①mMessages == null不存在消息，需要唤醒后设置nextPollTimeoutMillis = -1；</span></div><div class="line">                <span class="comment">// ②mMessages.target != null 存在非同步分隔栏消息，需要唤醒，从新处理消息（同步消息解禁需要处理。这里剩余消息都是异步消息无需再次唤醒）</span></div><div class="line">                <span class="comment">//如果其后还是同步分隔栏，无需再次唤醒，按照上次设置的唤醒时间处理即可</span></div><div class="line">                mMessages = p.next;</div><div class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            p.recycleUnchecked();</div><div class="line"></div><div class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></div><div class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></div><div class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-消息的获取"><a href="#4-3-消息的获取" class="headerlink" title="4.3 消息的获取"></a>4.3 消息的获取</h3><p>消息获取是通过<code>next()</code>完成的，下面是详细分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 基本算法：</div><div class="line">     * 1.获取待处理消息，消息队列为空，处理idlehandler，永久阻塞队列，等待消息插入等操作唤醒阻塞；反之，进入2；</div><div class="line">     * 2.获取消息非空，判断当前是或否需要处理，不需要，设置下次唤醒时间，利用空闲处理idlehandler；反之，进入3；</div><div class="line">     * 3.返回要处理的消息</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">        <span class="comment">// which is not supported.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;<span class="comment">//当消息循环已经退出，则直接返回</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration 第一次迭代为-1</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//调用native层进行消息标示  0立即返回；－1 等待直到唤醒；&gt;0 阻塞等待指定时间</span></div><div class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//存在同步分隔栏，通过同步消息，寻找异步消息</span></div><div class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                        <span class="comment">//消息还未到处理时间，重新设置阻塞时间</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Got a message.</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;<span class="comment">//标识消息队列为阻塞</span></div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mMessages = msg.next;<span class="comment">//重新设置队首节点</span></div><div class="line">                        &#125;</div><div class="line">                        msg.next = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;<span class="comment">//返回需要处理消息</span></div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// No more messages. 不存在消息，永久阻塞，直到下次插入消息或者移除消息将其唤醒</span></div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">                <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//消息机制在退出，执行native的销毁方法</span></div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">                <span class="comment">//第一次进入该函数，当消息队列无消息时或者当前无消息处理。</span></div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//无IdleHandler处理，当前消息队列阻塞</span></div><div class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                    mBlocked = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//初始化待处理IdleHandler</span></div><div class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> MessageQueue.IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">                &#125;</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Run the idle handlers.</span></div><div class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">            <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">                <span class="keyword">final</span> MessageQueue.IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其中需要说明的是：</p>
<ul>
<li>函数<code>nativePollOnce(long ptr, int timeoutMillis)</code>是native方法，其作用是让出CPU，阻塞指定timeoutMillis时间。将在下一篇说明；</li>
<li>IdleHandler是在无消息处理时，捎带处理任务。可以用于其统计一下页面的渲染时间（消息发送完了说明UI已经渲染完了），或者算一下屏幕是否长时间没操作等等,详见参考[5]。</li>
</ul>
<h3 id="4-4-消息队列退出"><a href="#4-4-消息队列退出" class="headerlink" title="4.4 消息队列退出"></a>4.4 消息队列退出</h3><p>消息队列在looper的驱使下，会不断地插入和移除消息。当整个消息机制handler完成使命时，就会退出消息队列，进入结束对应的线程。消息队列tig对应的函数<code>quit(boolean safe)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 消息队列退出</div><div class="line">     * <span class="doctag">@param</span> safe 是否安全退出</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;<span class="comment">//ui消息机制不允许退出</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//已经在退出</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (safe) &#123;<span class="comment">//保留当前时间之前未处理消息</span></div><div class="line">                removeAllFutureMessagesLocked();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//移除队列所有消息</span></div><div class="line">                removeAllMessagesLocked();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//唤醒休眠，使得looper执行完成，工作线程结束</span></div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="五、Handler"><a href="#五、Handler" class="headerlink" title="五、Handler"></a>五、Handler</h2><p>Handler主要作用有二：1、在指定的时间点执行操作（异步）；2、不同线程执行操作（跨线程通信）</p>
<h3 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h3><h4 id="5-1-1-无参构造函数"><a href="#5-1-1-无参构造函数" class="headerlink" title="5.1.1 无参构造函数"></a>5.1.1 无参构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Default constructor associates this handler with the &#123;<span class="doctag">@link</span> Looper&#125; for the</div><div class="line">     * current thread.</div><div class="line">     * </div><div class="line">     * If this thread does not have a looper, this handler won't be able to receive messages</div><div class="line">     * so an exception is thrown.</div><div class="line">     * 1.无参构造函数默认使用当前线程looper，若当前线程无looper将抛出异常。</div><div class="line">     * 2.默认构造消息是同步消息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">/**</span></div><div class="line">     * 1.callback为Handler绑定消息回调；</div><div class="line">     * 2.获取当下线程的looper为空，抛出异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Handler.Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<span class="comment">//警告由handler引发的内存泄漏。匿名类、内部类或本地类都必须申明为static</span></div><div class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                        klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取当下线程的looper</span></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//初始化对应的消息队列</span></div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="5-1-2-有参构造函数"><a href="#5-1-2-有参构造函数" class="headerlink" title="5.1.2 有参构造函数"></a>5.1.2 有参构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Use the provided &#123;<span class="doctag">@link</span> Looper&#125; instead of the default one.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> looper The looper, must not be null.</div><div class="line">    * 指定looper，且必须在执行的Looper.prepare()后，创建handler</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * </div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Handler.Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">       mLooper = looper;</div><div class="line">       mQueue = looper.mQueue;</div><div class="line">       mCallback = callback;</div><div class="line">       mAsynchronous = async;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-发送消息"><a href="#5-2-发送消息" class="headerlink" title="5.2 发送消息"></a>5.2 发送消息</h3><p>主要由各种形式的消息发送函数构成，最终将消息按照绝对时间放入消息队列。主要介绍函数<code>sendMessageDelayed(Message msg, long delayMillis)</code>和<code>sendMessageAtFrontOfQueue(Message msg)</code><br><img src="/2018/05/01/handler-1/handler-message.png" alt="Handler简图">   </p>
<h4 id="5-2-1-函数-sendMessageDelayed"><a href="#5-2-1-函数-sendMessageDelayed" class="headerlink" title="5.2.1 函数 sendMessageDelayed"></a>5.2.1 函数 <code>sendMessageDelayed</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Enqueue a message into the message queue after all pending messages</div><div class="line">    * before (current time + delayMillis). You will receive it in</div><div class="line">    * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </div><div class="line">    *         message queue.  Returns false on failure, usually because the</div><div class="line">    *         looper processing the message queue is exiting.  Note that a</div><div class="line">    *         result of true does not mean the message will be processed -- if</div><div class="line">    *         the looper is quit before the delivery time of the message</div><div class="line">    *         occurs then the message will be dropped.</div><div class="line">    * 按照绝对时间插入消息队列。出入成功后，返回true；反之亦然。出入失败的原因有可能，当前消息机制正在关闭等         </div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">   &#123;</div><div class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">           delayMillis = <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-2-函数sendMessageAtFrontOfQueue"><a href="#5-2-2-函数sendMessageAtFrontOfQueue" class="headerlink" title="5.2.2 函数sendMessageAtFrontOfQueue"></a>5.2.2 函数<code>sendMessageAtFrontOfQueue</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Enqueue a message at the front of the message queue, to be processed on</div><div class="line">     * the next iteration of the message loop.  You will receive it in</div><div class="line">     * &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached to this handler.</div><div class="line">     * &lt;b&gt;This method is only for use in very special circumstances -- it</div><div class="line">     * can easily starve the message queue, cause ordering problems, or have</div><div class="line">     * other unexpected side-effects.&lt;/b&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </div><div class="line">     *         message queue.  Returns false on failure, usually because the</div><div class="line">     *         looper processing the message queue is exiting.</div><div class="line">     * 将该消息置于消息队列头部，实现方式将其执行时间设为0，自然插入到队首        </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上述众多发送消息函数，最终通过函数<code>enqueueMessage</code>完成消息的入队。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 一系列消息发送函数的最后入口函数</div><div class="line">     * <span class="doctag">@param</span> queue 消息队列</div><div class="line">     * <span class="doctag">@param</span> msg 消息</div><div class="line">     * <span class="doctag">@param</span> uptimeMillis 消息触发时间= 系统时间+延迟时间</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        <span class="comment">//设置消息处理者</span></div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;<span class="comment">//设置消息是否异步</span></div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="5-3-处理消息"><a href="#5-3-处理消息" class="headerlink" title="5.3 处理消息"></a>5.3 处理消息</h3><p>在Looper.loop()中，当发现有消息时，进行消息的分发，消息存在handler，就调用消息的目标handler，执行函数<code>dispatchMessage</code>方法来处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Handle system messages here.</div><div class="line">     * 消息处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">//1. 消息自身携带回调，执行msg.callback.run()方法</span></div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//2.handler 设置callback回调，执行回调方法handleMessage()；</span></div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//3.执行Handler自身的成员方法handleMessage()</span></div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>处理消息的步骤：</p>
<ol>
<li>消息自身携带回调，执行<code>msg.callback.run()</code>方法，结束消息的处理；反之，进入步骤2；  </li>
<li>handler设置处理消息回调，则执行回调方法<code>handleMessage()</code>。如果该方法返回true，结束消息处理，反之，进入步骤3；  </li>
<li>执行Handler自身的成员方法<code>handleMessage()</code>。</li>
</ol>
<h3 id="5-4-移除消息"><a href="#5-4-移除消息" class="headerlink" title="5.4 移除消息"></a>5.4 移除消息</h3><p>移除消息包含以下三个函数：</p>
<ul>
<li><code>removeMessages(int what)</code> :移除队列指定类型的消息；</li>
<li><code>removeMessages(int what, Object object)</code>：移除队列指定token的消息；  </li>
<li><code>removeCallbacksAndMessages(Object token)</code>：移除队列指定token的消息和回调，如果token为<strong>null</strong>，将会移除消息队列中所有消息和回调。在handler所处的activity和Fragment的<code>onDestory()</code>中执行该方法，能够避免内存泄漏。</li>
</ul>
<h2 id="六-Looper"><a href="#六-Looper" class="headerlink" title="六 Looper"></a>六 Looper</h2><p>Looper作为一个消息的分发者，将消息不断地分发给目标执行者。主要包含两个函数<code>prepare(boolean quitAllowed)</code>和<code>loop()</code>。  </p>
<h3 id="6-1-函数prepare-boolean-quitAllowed"><a href="#6-1-函数prepare-boolean-quitAllowed" class="headerlink" title="6.1 函数prepare(boolean quitAllowed)"></a>6.1 函数<code>prepare(boolean quitAllowed)</code></h3><p>函数prepare(boolean quitAllowed)为消息机制循环做一下准备工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Initialize the current thread as a looper.</div><div class="line">     * This gives you a chance to create handlers that then reference</div><div class="line">     * this looper, before actually starting the loop. Be sure to call</div><div class="line">     * 创建looper对象。可以在handler创建的时候指定looper</div><div class="line">     * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">     * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> quitAllowed</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> quitAllowed</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建消息队列</span></div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="6-2-函数loop"><a href="#6-2-函数loop" class="headerlink" title="6.2 函数loop()"></a>6.2 函数<code>loop()</code></h3><p>函数<code>loop()</code>不断获取消息、分发消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Run the message queue in this thread. Be sure to call</div><div class="line">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line">     *</div><div class="line">     * 不断地获取消息，导致主动调用quit()结束</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;<span class="comment">//获取当前线程对应的looper</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next(); <span class="comment">//该方法是一个阻塞式方法</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">            <span class="comment">//默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span></div><div class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//消息分发</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                msg.target.dispatchMessage(msg);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                    Trace.traceEnd(traceTag);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//消息复用</span></div><div class="line">            msg.recycleUnchecked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>借用参考[1]中图，来说明handler消息机制。<br><img src="/2018/05/01/handler-1/handler-flow.png" alt="Handler流程"> </p>
<ol>
<li>handler不断发送消息到消息队列;</li>
<li>Looper依据消息的处理时间不断挂起、唤醒消息队列；</li>
<li>Looper将需要处理的消息交友target处理；</li>
</ol>
<h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><ol>
<li><a href="http://tengj.top/2016/04/12/javajhtotal/" target="_blank" rel="external">handler-java详解</a></li>
<li><a href="https://my.oschina.net/youranhongcha/blog/492591" target="_blank" rel="external">handler详解</a> </li>
<li><a href="https://www.colabug.com/195754.html" target="_blank" rel="external">SyncBarrier解析</a></li>
<li><a href="https://blog.csdn.net/cdecde111/article/details/54670136" target="_blank" rel="external">SyncBarrier应用</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1006147" target="_blank" rel="external">ihandler解释</a> </li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/19/LinkedHashMap源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/19/LinkedHashMap源码分析/" itemprop="url">LinkedHashMap源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-19T22:03:20+08:00">
                2017-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Map/" itemprop="url" rel="index">
                    <span itemprop="name">Map</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于HashMap不保存数据的顺序，jdk在此基础上提出LinkedHashMap，其内部使用双向列表维持数据的顺序。注意这里的顺序有两种：1. 插入顺序；2. 访问顺序<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/08/19/LinkedHashMap源码分析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/HashMap源码分析（1-8版本）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/HashMap源码分析（1-8版本）/" itemprop="url">HashMap源码分析（1.8版本）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T14:05:57+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Map/" itemprop="url" rel="index">
                    <span itemprop="name">Map</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap1.7版本内部使用数组+双向列表结构。即使再好的hash函数，也难以保证数据均匀地散列到各个桶中，当大量数据位于同一个桶中的情况下，获取数据的时间复杂度为O(n)，其中n代表hashmap链表长度。针对该问题，Hashmap1.8版本使用数组+双向列表/红黑树结构，解决大量数据位于同一个桶数据获取效率问题。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/08/12/HashMap源码分析（1-8版本）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/HashMap源码分析（1-7版本）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/HashMap源码分析（1-7版本）/" itemprop="url">HashMap源码分析（1.7版本）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T20:13:35+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Map/" itemprop="url" rel="index">
                    <span itemprop="name">Map</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap是一个用”KEY”-“VALUE”来实现数据存储的类。可以依据”key”存储数据。也可以通过”key”去得到数据。所以你可以把HashMap当作一个字典。<br>由于HashMap实现方式在<strong>jdk1.7</strong>和<strong>jdk1.8</strong>版本间做了较大修改，本文以<strong>jdk1.7</strong>版本展开分析，下一篇日志以<strong>jdk1.8</strong>版本分析，并对他们做比较、总结。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/08/06/HashMap源码分析（1-7版本）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/LinkedList源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/LinkedList源码分析/" itemprop="url">LinkedList源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T19:10:33+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/List/" itemprop="url" rel="index">
                    <span itemprop="name">List</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedList是线性表中的链式存储结构的顺序表。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/08/03/LinkedList源码分析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/01/ArrayList源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/ArrayList源码分析/" itemprop="url">ArrayList源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T21:13:26+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/List/" itemprop="url" rel="index">
                    <span itemprop="name">List</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList基于数组实现，使用一个动态数组保存数据，其容量自动增加。<br></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/08/01/ArrayList源码分析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/29/Java-集合类概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="taoyongzhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陶永臻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/29/Java-集合类概述/" itemprop="url">Java 集合类概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T22:37:29+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Collection/" itemprop="url" rel="index">
                    <span itemprop="name">Collection</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h2><p>首先需要理解集合的概念，集合是指由同类元素的整体。而java集合是指java提供的一套工具包，以方便用户的使用，包含了常用的数据结构：队列、链表、栈等。Java集合框架是指实现该工具包的一套规范，用来表示、操作集合，用以方便使用者理解、使用其中的数据结构。<br>学习、使用每一类集合时，需要从以下几个维度进行把握：  </p>
<ul>
<li>基本操作：增删改查，注意支持重复元素、NULL元素处理等。  </li>
<li>线程安全：是不是支持多线程，以及实现多线程安全的方式。  </li>
<li>效率: 空间复杂度和时间复杂度，包括基本操作的时间复杂度等。</li></ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/07/29/Java-集合类概述/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="taoyongzhen" />
          <p class="site-author-name" itemprop="name">taoyongzhen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">taoyongzhen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
